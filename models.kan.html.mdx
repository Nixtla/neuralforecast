---
output-file: models.kan.html
title: KAN
---


------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/kan.py#L18"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### KANLinear

> ``` text
>  KANLinear (in_features, out_features, grid_size=5, spline_order=3,
>             scale_noise=0.1, scale_base=1.0, scale_spline=1.0,
>             enable_standalone_scale_spline=True, base_activation=<class
>             'torch.nn.modules.activation.SiLU'>, grid_eps=0.02,
>             grid_range=[-1, 1])
> ```

\*Base class for all neural network modules.

Your models should also subclass this class.

Modules can also contain other Modules, allowing to nest them in a tree
structure. You can assign the submodules as regular attributes::

``` text
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))
```

Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:`to`, etc.

.. note:: As per the example above, an `__init__()` call to the parent
class must be made before assignment on the child.

:ivar training: Boolean represents whether this module is in training or
evaluation mode. :vartype training: bool\*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/kan.py#L239"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### KAN

> ``` text
>  KAN (h, input_size, grid_size:int=5, spline_order:int=3,
>       scale_noise:float=0.1, scale_base:float=1.0, scale_spline:float=1.0,
>       enable_standalone_scale_spline:bool=True, grid_eps:float=0.02,
>       grid_range:list=[-1, 1], n_hidden_layers:int=1,
>       hidden_size:Union[int,list]=512, futr_exog_list=None,
>       hist_exog_list=None, stat_exog_list=None, exclude_insample_y=False,
>       loss=MAE(), valid_loss=None, max_steps:int=1000,
>       learning_rate:float=0.001, num_lr_decays:int=-1,
>       early_stop_patience_steps:int=-1, val_check_steps:int=100,
>       batch_size:int=32, valid_batch_size:Optional[int]=None,
>       windows_batch_size=1024, inference_windows_batch_size=-1,
>       start_padding_enabled=False, step_size:int=1,
>       scaler_type:str='identity', random_seed:int=1,
>       num_workers_loader:int=0, drop_last_loader:bool=False,
>       optimizer=None, optimizer_kwargs=None, **trainer_kwargs)
> ```

\*KAN

Simple Kolmogorov-Arnold Network (KAN). This network uses the
Kolmogorov-Arnold approximation theorem, where splines are learned to
approximate more complex functions. Unlike the MLP, the non-linear
function are learned at the edges, and the nodes simply sum the
different learned functions.

**Parameters:**<br/> `h`: int, forecast horizon.<br/> `input_size`: int,
considered autorregresive inputs (lags), y=\[1,2,3,4\] input_size=2 -\>
lags=\[1,2\].<br/> `grid_size`: int, number of intervals used by the
splines to approximate the function.<br/> `spline_order`: int, order of
the B-splines.<br/> `scale_noise`: float, regularization coefficient for
the splines.<br/> `scale_base`: float, scaling coefficient for the base
function.<br/> `scale_spline`: float, scaling coefficient for the
splines.<br/> `enable_standalone_scale_spline`: bool, whether each spline
is scaled individually.<br/> `grid_eps`: float, used for numerical
stability.<br/> `grid_range`: list, range of the grid used for spline
approximation.<br/> `stat_exog_list`: str list, static exogenous
columns.<br/> `hist_exog_list`: str list, historic exogenous columns.<br/>
`futr_exog_list`: str list, future exogenous columns.<br/>
`exclude_insample_y`: bool=False, the model skips the autoregressive
features y\[t-input_size:t\] if True.<br/> `n_hidden_layers`: int, number
of hidden layers for the KAN.<br/> `hidden_size`: int or list, number of
units for each hidden layer of the KAN. If an integer, all hidden layers
will have the same size. Use a list to specify the size of each hidden
layer.<br/> `loss`: PyTorch module, instantiated train loss class from
[losses
collection](https://nixtla.github.io/neuralforecast/losses.pytorch.html).<br/>
`valid_loss`: PyTorch module=`loss`, instantiated valid loss class from
[losses
collection](https://nixtla.github.io/neuralforecast/losses.pytorch.html).<br/>
`max_steps`: int=1000, maximum number of training steps.<br/>
`learning_rate`: float=1e-3, Learning rate between (0, 1).<br/>
`num_lr_decays`: int=-1, Number of learning rate decays, evenly
distributed across max_steps.<br/> `early_stop_patience_steps`: int=-1,
Number of validation iterations before early stopping.<br/>
`val_check_steps`: int=100, Number of training steps between every
validation loss check.<br/> `batch_size`: int=32, number of different
series in each batch.<br/> `valid_batch_size`: int=None, number of
different series in each validation and test batch, if None uses
batch_size.<br/> `windows_batch_size`: int=1024, number of windows to
sample in each training batch, default uses all.<br/>
`inference_windows_batch_size`: int=-1, number of windows to sample in
each inference batch, -1 uses all.<br/> `start_padding_enabled`:
bool=False, if True, the model will pad the time series with zeros at
the beginning, by input size.<br/> `step_size`: int=1, step size between
each window of temporal data.<br/> `scaler_type`: str=‘identity’, type of
scaler for temporal inputs normalization see [temporal
scalers](https://nixtla.github.io/neuralforecast/common.scalers.html).<br/>
`random_seed`: int=1, random_seed for pytorch initializer and numpy
generators.<br/> `num_workers_loader`: int=os.cpu_count(), workers to be
used by `TimeSeriesDataLoader`.<br/> `drop_last_loader`: bool=False, if
True `TimeSeriesDataLoader` drops last non-full batch.<br/> `alias`: str,
optional, Custom name of the model.<br/> `optimizer`: Subclass of
‘torch.optim.Optimizer’, optional, user specified optimizer instead of
the default choice (Adam).<br/> `optimizer_kwargs`: dict, optional, list
of parameters used by the user specified `optimizer`.<br/>
`**trainer_kwargs`: int, keyword trainer arguments inherited from
[PyTorch Lighning’s
trainer](https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.trainer.trainer.trainer.html?highlight=trainer).<br/>

**References**<br/> - [Ziming Liu, Yixuan Wang, Sachin Vaidya, Fabian
Ruehle, James Halverson, Marin Soljačić, Thomas Y. Hou, Max Tegmark.
“KAN: Kolmogorov-Arnold Networks”](https://arxiv.org/abs/2404.19756)\*

```python
import numpy as np
import pandas as pd
import pytorch_lightning as pl
import matplotlib.pyplot as plt

from neuralforecast import NeuralForecast
from neuralforecast.models import KAN
from neuralforecast.losses.pytorch import MAE
from neuralforecast.utils import AirPassengersPanel
```


```python
Y_train_df = AirPassengersPanel[AirPassengersPanel.ds<AirPassengersPanel['ds'].values[-12]] # 132 train
Y_test_df = AirPassengersPanel[AirPassengersPanel.ds>=AirPassengersPanel['ds'].values[-12]].reset_index(drop=True) # 12 test

model = KAN(h=12, input_size=24,
            loss=MAE(),
            scaler_type='robust',
            learning_rate=1e-3,
            max_steps=200,
            val_check_steps=10,
            early_stop_patience_steps=2)

fcst = NeuralForecast(
    models=[model],
    freq='M'
)

fcst.fit(df=Y_train_df, val_size=12)
forecasts = fcst.predict(futr_df=Y_test_df)
```


```python
Y_hat_df = forecasts.reset_index(drop=False).drop(columns=['unique_id','ds'])
plot_df = pd.concat([Y_test_df, Y_hat_df], axis=1)
plot_df = pd.concat([Y_train_df, plot_df])

plot_df = plot_df[plot_df.unique_id=='Airline1'].drop('unique_id', axis=1)
plt.plot(plot_df['ds'], plot_df['y'], c='black', label='True')
plt.plot(plot_df['ds'], plot_df['KAN'], c='blue', label='median')
plt.grid()
plt.legend()
plt.plot()
```

