---
output-file: models.stemgnn.html
title: StemGNN

---

The Spectral Temporal Graph Neural Network
([`StemGNN`](https://Nixtla.github.io/neuralforecast/models.stemgnn.html#stemgnn))
is a Graph-based multivariate time-series forecasting model.
[`StemGNN`](https://Nixtla.github.io/neuralforecast/models.stemgnn.html#stemgnn)
jointly learns temporal dependencies and inter-series correlations in
the spectral domain, by combining Graph Fourier Transform (GFT) and
Discrete Fourier Transform (DFT).

This method proved state-of-the-art performance on geo-temporal datasets
such as `Solar`, `METR-LA`, and `PEMS-BAY`, and

**References**<br/> -[Defu Cao, Yujing Wang, Juanyong Duan, Ce Zhang, Xia
Zhu, Congrui Huang, Yunhai Tong, Bixiong Xu, Jing Bai, Jie Tong, Qi
Zhang (2020). “Spectral Temporal Graph Neural Network for Multivariate
Time-series
Forecasting”.](https://proceedings.neurips.cc/paper/2020/hash/cdf6581cb7aca4b7e19ef136c6e601a5-Abstract.html)

![Figure 1. StemGNN.](/imgs_models/stemgnn.png)

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/tft.py#L37"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### GLU

> ``` text
>  GLU (input_channel, output_channel)
> ```

Base class for all neural network modules.

Your models should also subclass this class.

Modules can also contain other Modules, allowing to nest them in a tree
structure. You can assign the submodules as regular attributes::

``` text
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))
```

Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:`to`, etc.

.. note:: As per the example above, an `__init__()` call to the parent
class must be made before assignment on the child.

:ivar training: Boolean represents whether this module is in training or
evaluation mode. :vartype training: bool

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/stemgnn.py#L25"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### StockBlockLayer

> ``` text
>  StockBlockLayer (time_step, unit, multi_layer, stack_cnt=0)
> ```

Base class for all neural network modules.

Your models should also subclass this class.

Modules can also contain other Modules, allowing to nest them in a tree
structure. You can assign the submodules as regular attributes::

``` text
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))
```

Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:`to`, etc.

.. note:: As per the example above, an `__init__()` call to the parent
class must be made before assignment on the child.

:ivar training: Boolean represents whether this module is in training or
evaluation mode. :vartype training: bool

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/stemgnn.py#L131"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### StemGNN

> ``` text
>  StemGNN (h, input_size, n_series, futr_exog_list=None,
>           hist_exog_list=None, stat_exog_list=None, n_stacks=2,
>           multi_layer:int=5, dropout_rate:float=0.5, leaky_rate:float=0.2,
>           loss=MAE(), valid_loss=None, max_steps:int=1000,
>           learning_rate:float=0.001, num_lr_decays:int=3,
>           early_stop_patience_steps:int=-1, val_check_steps:int=100,
>           batch_size:int=32, step_size:int=1, scaler_type:str='robust',
>           random_seed:int=1, num_workers_loader=0, drop_last_loader=False,
>           **trainer_kwargs)
> ```

StemGNN

The Spectral Temporal Graph Neural Network
([`StemGNN`](https://Nixtla.github.io/neuralforecast/models.stemgnn.html#stemgnn))
is a Graph-based multivariate time-series forecasting model.
[`StemGNN`](https://Nixtla.github.io/neuralforecast/models.stemgnn.html#stemgnn)
jointly learns temporal dependencies and inter-series correlations in
the spectral domain, by combining Graph Fourier Transform (GFT) and
Discrete Fourier Transform (DFT).

**Parameters:**<br/> `h`: int, Forecast horizon. <br/> `input_size`: int,
autorregresive inputs size, y=\[1,2,3,4\] input_size=2 -\>
y\_\[t-2:t\]=\[1,2\].<br/> `n_series`: int, number of time-series.<br/>
`stat_exog_list`: str list, static exogenous columns.<br/>
`hist_exog_list`: str list, historic exogenous columns.<br/>
`futr_exog_list`: str list, future exogenous columns.<br/> `n_stacks`:
int=2, number of stacks in the model.<br/> `multi_layer`: int=5,
multiplier for FC hidden size on StemGNN blocks.<br/> `dropout_rate`:
float=0.5, dropout rate.<br/> `leaky_rate`: float=0.2, alpha for
LeakyReLU layer on Latent Correlation layer.<br/> `loss`: PyTorch module,
instantiated train loss class from [losses
collection](https://nixtla.github.io/neuralforecast/losses.pytorch.html).<br/>
`valid_loss`: PyTorch module=`loss`, instantiated valid loss class from
[losses
collection](https://nixtla.github.io/neuralforecast/losses.pytorch.html).<br/>
`max_steps`: int=1000, maximum number of training steps.<br/>
`learning_rate`: float=1e-3, Learning rate between (0, 1).<br/>
`num_lr_decays`: int=-1, Number of learning rate decays, evenly
distributed across max_steps.<br/> `early_stop_patience_steps`: int=-1,
Number of validation iterations before early stopping.<br/>
`val_check_steps`: int=100, Number of training steps between every
validation loss check.<br/> `batch_size`: int, number of windows in each
batch.<br/> `step_size`: int=1, step size between each window of temporal
data.<br/> `scaler_type`: str=‘robust’, type of scaler for temporal
inputs normalization see [temporal
scalers](https://nixtla.github.io/neuralforecast/common.scalers.html).<br/>
`random_seed`: int, random_seed for pytorch initializer and numpy
generators.<br/> `num_workers_loader`: int=os.cpu_count(), workers to be
used by `TimeSeriesDataLoader`.<br/> `drop_last_loader`: bool=False, if
True `TimeSeriesDataLoader` drops last non-full batch.<br/> `alias`: str,
optional, Custom name of the model.<br/> `**trainer_kwargs`: int, keyword
trainer arguments inherited from [PyTorch Lighning’s
trainer](https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.trainer.trainer.Trainer.html?highlight=trainer).<br/>

## Usage Examples

Train model and forecast future values with `predict` method.

```python
import numpy as np
import pandas as pd
import pytorch_lightning as pl
import matplotlib.pyplot as plt

from neuralforecast import NeuralForecast
from neuralforecast.utils import AirPassengersPanel, AirPassengersStatic
from neuralforecast.losses.pytorch import MAE

Y_train_df = AirPassengersPanel[AirPassengersPanel.ds<AirPassengersPanel['ds'].values[-12]].reset_index(drop=True) # 132 train
Y_test_df = AirPassengersPanel[AirPassengersPanel.ds>=AirPassengersPanel['ds'].values[-12]].reset_index(drop=True) # 12 test

model = StemGNN(h=12,
                input_size=24,
                n_series=2,
                stat_exog_list=['airline1'],
                futr_exog_list=['trend'],
                scaler_type='robust',
                max_steps=200,
                early_stop_patience_steps=-1,
                val_check_steps=10,
                learning_rate=1e-3,
                loss=MAE(),
                valid_loss=None,
                batch_size=32
                )

fcst = NeuralForecast(models=[model], freq='M')
fcst.fit(df=Y_train_df, static_df=AirPassengersStatic, val_size=12)
forecasts = fcst.predict(futr_df=Y_test_df)
```


```python
# Plot quantile predictions
Y_hat_df = forecasts.reset_index(drop=False).drop(columns=['unique_id','ds'])
plot_df = pd.concat([Y_test_df, Y_hat_df], axis=1)
plot_df = pd.concat([Y_train_df, plot_df])

plot_df = plot_df[plot_df.unique_id=='Airline1'].drop('unique_id', axis=1)
plt.plot(plot_df['ds'], plot_df['y'], c='black', label='True')
plt.plot(plot_df['ds'], plot_df['StemGNN'], c='blue', label='Forecast')
plt.legend()
plt.grid()
```

Using `cross_validation` to forecast multiple historic values.

```python
fcst = NeuralForecast(models=[model], freq='M')
forecasts = fcst.cross_validation(df=AirPassengersPanel, static_df=AirPassengersStatic, n_windows=2, step_size=12)
```


```python
# Plot quantile predictions
Y_hat_df = forecasts[forecasts['unique_id']=='Airline1']
Y_df = AirPassengersPanel[AirPassengersPanel['unique_id']=='Airline1']

plt.plot(Y_df['ds'], Y_df['y'], c='black', label='True')
plt.plot(Y_hat_df['ds'], Y_hat_df['StemGNN'], c='blue', label='Forecast')
plt.legend()
plt.grid()
```

