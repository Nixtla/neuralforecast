---
output-file: models.lstm.html
title: LSTM
---


The Long Short-Term Memory Recurrent Neural Network
([`LSTM`](https://nixtlaverse.nixtla.io/neuralforecast/models.lstm.html#lstm)),
uses a multilayer
[`LSTM`](https://nixtlaverse.nixtla.io/neuralforecast/models.lstm.html#lstm)
encoder and an
[`MLP`](https://nixtlaverse.nixtla.io/neuralforecast/models.mlp.html#mlp)
decoder. It builds upon the LSTM-cell that improves the exploding and
vanishing gradients of classic
[`RNN`](https://nixtlaverse.nixtla.io/neuralforecast/models.rnn.html#rnn)’s.
This network has been extensively used in sequential prediction tasks
like language modeling, phonetic labeling, and forecasting. The
predictions are obtained by transforming the hidden states into contexts
$\mathbf{c}_{[t+1:t+H]}$, that are decoded and adapted into
$\mathbf{\hat{y}}_{[t+1:t+H],[q]}$ through MLPs.

where $\mathbf{h}_{t}$, is the hidden state for time $t$,
$\mathbf{y}_{t}$ is the input at time $t$ and $\mathbf{h}_{t-1}$ is the
hidden state of the previous layer at $t-1$, $\mathbf{x}^{(s)}$ are
static exogenous inputs, $\mathbf{x}^{(h)}_{t}$ historic exogenous,
$\mathbf{x}^{(f)}_{[:t+H]}$ are future exogenous available at the time
of the prediction.

**References**<br/>-[Jeffrey L. Elman (1990). “Finding Structure in
Time”.](https://onlinelibrary.wiley.com/doi/abs/10.1207/s15516709cog1402_1)<br/>-[Haşim
Sak, Andrew Senior, Françoise Beaufays (2014). “Long Short-Term Memory
Based Recurrent Neural Network Architectures for Large Vocabulary Speech
Recognition.”](https://arxiv.org/abs/1402.1128)<br/>

<figure>
<img src="imgs_models/lstm.png"
alt="Figure 1. Long Short-Term Memory Cell." />
<figcaption aria-hidden="true">Figure 1. Long Short-Term Memory
Cell.</figcaption>
</figure>

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/lstm.py#L18"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### LSTM

> ``` text
>  LSTM (h:int, input_size:int=-1, inference_input_size:Optional[int]=None,
>        h_train:int=1, encoder_n_layers:int=2, encoder_hidden_size:int=128,
>        encoder_bias:bool=True, encoder_dropout:float=0.0,
>        context_size:Optional[int]=None, decoder_hidden_size:int=128,
>        decoder_layers:int=2, futr_exog_list=None, hist_exog_list=None,
>        stat_exog_list=None, exclude_insample_y=False, recurrent=False,
>        loss=MAE(), valid_loss=None, max_steps:int=1000,
>        learning_rate:float=0.001, num_lr_decays:int=-1,
>        early_stop_patience_steps:int=-1, val_check_steps:int=100,
>        batch_size=32, valid_batch_size:Optional[int]=None,
>        windows_batch_size=128, inference_windows_batch_size=1024,
>        start_padding_enabled=False, step_size:int=1,
>        scaler_type:str='robust', random_seed=1, drop_last_loader=False,
>        alias:Optional[str]=None, optimizer=None, optimizer_kwargs=None,
>        lr_scheduler=None, lr_scheduler_kwargs=None,
>        dataloader_kwargs=None, **trainer_kwargs)
> ```

\*LSTM

LSTM encoder, with MLP decoder. The network has `tanh` or `relu`
non-linearities, it is trained using ADAM stochastic gradient descent.
The network accepts static, historic and future exogenous data.

**Parameters:**<br/> `h`: int, forecast horizon.<br/> `input_size`: int,
maximum sequence length for truncated train backpropagation. Default -1
uses 3 \* horizon <br/> `inference_input_size`: int, maximum sequence
length for truncated inference. Default None uses input_size
history.<br/> `h_train`: int, maximum sequence length for truncated train
backpropagation. Default 1.<br/> `encoder_n_layers`: int=2, number of
layers for the LSTM.<br/> `encoder_hidden_size`: int=200, units for the
LSTM’s hidden state size.<br/> `encoder_bias`: bool=True, whether or not
to use biases b_ih, b_hh within LSTM units.<br/> `encoder_dropout`:
float=0., dropout regularization applied to LSTM outputs.<br/>
`context_size`: deprecated.<br/> `decoder_hidden_size`: int=200, size of
hidden layer for the MLP decoder.<br/> `decoder_layers`: int=2, number of
layers for the MLP decoder.<br/> `futr_exog_list`: str list, future
exogenous columns.<br/> `hist_exog_list`: str list, historic exogenous
columns.<br/> `stat_exog_list`: str list, static exogenous columns.<br/>
`exclude_insample_y`: bool=False, whether to exclude the target variable
from the input.<br/> `recurrent`: bool=False, whether to produce
forecasts recursively (True) or direct (False).<br/> `loss`: PyTorch
module, instantiated train loss class from [losses
collection](https://nixtla.github.io/neuralforecast/losses.pytorch.html).<br/>
`valid_loss`: PyTorch module=`loss`, instantiated valid loss class from
[losses
collection](https://nixtla.github.io/neuralforecast/losses.pytorch.html).<br/>
`max_steps`: int=1000, maximum number of training steps.<br/>
`learning_rate`: float=1e-3, Learning rate between (0, 1).<br/>
`num_lr_decays`: int=-1, Number of learning rate decays, evenly
distributed across max_steps.<br/> `early_stop_patience_steps`: int=-1,
Number of validation iterations before early stopping.<br/>
`val_check_steps`: int=100, Number of training steps between every
validation loss check.<br/> `batch_size`: int=32, number of
differentseries in each batch.<br/> `valid_batch_size`: int=None, number
of different series in each validation and test batch.<br/>
`windows_batch_size`: int=128, number of windows to sample in each
training batch, default uses all.<br/> `inference_windows_batch_size`:
int=1024, number of windows to sample in each inference batch, -1 uses
all.<br/> `start_padding_enabled`: bool=False, if True, the model will
pad the time series with zeros at the beginning, by input size.<br/>
`step_size`: int=1, step size between each window of temporal
data.<br/>  
`scaler_type`: str=‘robust’, type of scaler for temporal inputs
normalization see [temporal
scalers](https://nixtla.github.io/neuralforecast/common.scalers.html).<br/>
`random_seed`: int=1, random_seed for pytorch initializer and numpy
generators.<br/> `drop_last_loader`: bool=False, if True
`TimeSeriesDataLoader` drops last non-full batch.<br/> `alias`: str,
optional, Custom name of the model.<br/> `optimizer`: Subclass of
‘torch.optim.Optimizer’, optional, user specified optimizer instead of
the default choice (Adam).<br/> `optimizer_kwargs`: dict, optional, list
of parameters used by the user specified `optimizer`.<br/>
`lr_scheduler`: Subclass of ‘torch.optim.lr_scheduler.LRScheduler’,
optional, user specified lr_scheduler instead of the default choice
(StepLR).<br/> `lr_scheduler_kwargs`: dict, optional, list of parameters
used by the user specified `lr_scheduler`.<br/>  
`dataloader_kwargs`: dict, optional, list of parameters passed into the
PyTorch Lightning dataloader by the `TimeSeriesDataLoader`. <br/>
`**trainer_kwargs`: int, keyword trainer arguments inherited from
[PyTorch Lighning’s
trainer](https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.trainer.trainer.Trainer.html?highlight=trainer).<br/>\*

------------------------------------------------------------------------

### LSTM.fit

> ``` text
>  LSTM.fit (dataset, val_size=0, test_size=0, random_seed=None,
>            distributed_config=None)
> ```

\*Fit.

The `fit` method, optimizes the neural network’s weights using the
initialization parameters (`learning_rate`, `windows_batch_size`, …) and
the `loss` function as defined during the initialization. Within `fit`
we use a PyTorch Lightning `Trainer` that inherits the initialization’s
`self.trainer_kwargs`, to customize its inputs, see [PL’s trainer
arguments](https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.trainer.trainer.Trainer.html?highlight=trainer).

The method is designed to be compatible with SKLearn-like classes and in
particular to be compatible with the StatsForecast library.

By default the `model` is not saving training checkpoints to protect
disk memory, to get them change `enable_checkpointing=True` in
`__init__`.

**Parameters:**<br/> `dataset`: NeuralForecast’s
[`TimeSeriesDataset`](https://nixtlaverse.nixtla.io/neuralforecast/tsdataset.html#timeseriesdataset),
see
[documentation](https://nixtla.github.io/neuralforecast/tsdataset.html).<br/>
`val_size`: int, validation size for temporal cross-validation.<br/>
`random_seed`: int=None, random_seed for pytorch initializer and numpy
generators, overwrites model.\_\_init\_\_’s.<br/> `test_size`: int, test
size for temporal cross-validation.<br/>\*

------------------------------------------------------------------------

### LSTM.predict

> ``` text
>  LSTM.predict (dataset, test_size=None, step_size=1, random_seed=None,
>                quantiles=None, **data_module_kwargs)
> ```

\*Predict.

Neural network prediction with PL’s `Trainer` execution of
`predict_step`.

**Parameters:**<br/> `dataset`: NeuralForecast’s
[`TimeSeriesDataset`](https://nixtlaverse.nixtla.io/neuralforecast/tsdataset.html#timeseriesdataset),
see
[documentation](https://nixtla.github.io/neuralforecast/tsdataset.html).<br/>
`test_size`: int=None, test size for temporal cross-validation.<br/>
`step_size`: int=1, Step size between each window.<br/> `random_seed`:
int=None, random_seed for pytorch initializer and numpy generators,
overwrites model.\_\_init\_\_’s.<br/> `quantiles`: list of floats,
optional (default=None), target quantiles to predict. <br/>
`**data_module_kwargs`: PL’s TimeSeriesDataModule args, see
[documentation](https://pytorch-lightning.readthedocs.io/en/1.6.1/extensions/datamodules.html#using-a-datamodule).\*

## Usage Example


```python
import pandas as pd
import matplotlib.pyplot as plt

from neuralforecast import NeuralForecast
from neuralforecast.models import LSTM
from neuralforecast.losses.pytorch import DistributionLoss
from neuralforecast.utils import AirPassengersPanel, AirPassengersStatic

Y_train_df = AirPassengersPanel[AirPassengersPanel.ds<AirPassengersPanel['ds'].values[-12]] # 132 train
Y_test_df = AirPassengersPanel[AirPassengersPanel.ds>=AirPassengersPanel['ds'].values[-12]].reset_index(drop=True) # 12 test

nf = NeuralForecast(
    models=[LSTM(h=12, 
                 input_size=8,
                 loss=DistributionLoss(distribution="Normal", level=[80, 90]),
                 scaler_type='robust',
                 encoder_n_layers=2,
                 encoder_hidden_size=128,
                 decoder_hidden_size=128,
                 decoder_layers=2,
                 max_steps=200,
                 futr_exog_list=['y_[lag12]'],
                 stat_exog_list=['airline1'],
                 recurrent=True,
                 h_train=1,
                 )
    ],
    freq='ME'
)
nf.fit(df=Y_train_df, static_df=AirPassengersStatic)
Y_hat_df = nf.predict(futr_df=Y_test_df)

# Plots
Y_hat_df = Y_hat_df.reset_index(drop=False).drop(columns=['unique_id','ds'])
plot_df = pd.concat([Y_test_df, Y_hat_df], axis=1)
plot_df = pd.concat([Y_train_df, plot_df])

plot_df = plot_df[plot_df.unique_id=='Airline1'].drop('unique_id', axis=1)
plt.plot(plot_df['ds'], plot_df['y'], c='black', label='True')
plt.plot(plot_df['ds'], plot_df['LSTM-median'], c='blue', label='median')
plt.fill_between(x=plot_df['ds'][-12:], 
                 y1=plot_df['LSTM-lo-90'][-12:].values,
                 y2=plot_df['LSTM-hi-90'][-12:].values,
                 alpha=0.4, label='level 90')
plt.grid()
plt.plot()
```

