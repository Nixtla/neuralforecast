---
description: >-
  Time-series Dense Encoder (`TiDE`) is a MLP-based univariate time-series
  forecasting model. `TiDE` uses Multi-layer Perceptrons (MLPs) in an
  encoder-decoder model for long-term time-series forecasting. In addition, this
  model can handle exogenous inputs.
output-file: models.tide.html
title: TiDE
---


<figure>
<img src="imgs_models/tide.png" alt="Figure 1. TiDE architecture." />
<figcaption aria-hidden="true">Figure 1. TiDE architecture.</figcaption>
</figure>

## 1. Auxiliary Functions

## 1.1 MLP residual

An MLP block with a residual connection.

### 2. Model

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/tide.py#L47"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TiDE

> ``` text
>  TiDE (h, input_size, hidden_size=512, decoder_output_dim=32,
>        temporal_decoder_dim=128, dropout=0.3, layernorm=True,
>        num_encoder_layers=1, num_decoder_layers=1, temporal_width=4,
>        futr_exog_list=None, hist_exog_list=None, stat_exog_list=None,
>        exclude_insample_y=False, loss=MAE(), valid_loss=None,
>        max_steps:int=1000, learning_rate:float=0.001,
>        num_lr_decays:int=-1, early_stop_patience_steps:int=-1,
>        val_check_steps:int=100, batch_size:int=32,
>        valid_batch_size:Optional[int]=None, windows_batch_size=1024,
>        inference_windows_batch_size=1024, start_padding_enabled=False,
>        step_size:int=1, scaler_type:str='identity', random_seed:int=1,
>        num_workers_loader:int=0, drop_last_loader:bool=False,
>        optimizer=None, optimizer_kwargs=None, lr_scheduler=None,
>        lr_scheduler_kwargs=None, **trainer_kwargs)
> ```

\*TiDE

Time-series Dense Encoder
([`TiDE`](https://Nixtla.github.io/neuralforecast/models.tide.html#tide))
is a MLP-based univariate time-series forecasting model.
[`TiDE`](https://Nixtla.github.io/neuralforecast/models.tide.html#tide)
uses Multi-layer Perceptrons (MLPs) in an encoder-decoder model for
long-term time-series forecasting.

**Parameters:**<br/> `h`: int, forecast horizon.<br/> `input_size`: int,
considered autorregresive inputs (lags), y=\[1,2,3,4\] input_size=2 -\>
lags=\[1,2\].<br/> `hidden_size`: int=1024, number of units for the dense
MLPs.<br/> `decoder_output_dim`: int=32, number of units for the output
of the decoder.<br/> `temporal_decoder_dim`: int=128, number of units for
the hidden sizeof the temporal decoder.<br/> `dropout`: float=0.0,
dropout rate between (0, 1) .<br/> `layernorm`: bool=True, if True uses
Layer Normalization on the MLP residual block outputs.<br/>
`num_encoder_layers`: int=1, number of encoder layers.<br/>
`num_decoder_layers`: int=1, number of decoder layers.<br/>
`temporal_width`: int=4, lower temporal projected dimension.<br/>
`futr_exog_list`: str list, future exogenous columns.<br/>
`hist_exog_list`: str list, historic exogenous columns.<br/>
`stat_exog_list`: str list, static exogenous columns.<br/>  
`loss`: PyTorch module, instantiated train loss class from [losses
collection](https://nixtla.github.io/neuralforecast/losses.pytorch.html).<br/>
`valid_loss`: PyTorch module=`loss`, instantiated valid loss class from
[losses
collection](https://nixtla.github.io/neuralforecast/losses.pytorch.html).<br/>
`max_steps`: int=1000, maximum number of training steps.<br/>
`learning_rate`: float=1e-3, Learning rate between (0, 1).<br/>
`num_lr_decays`: int=-1, Number of learning rate decays, evenly
distributed across max_steps.<br/> `early_stop_patience_steps`: int=-1,
Number of validation iterations before early stopping.<br/>
`val_check_steps`: int=100, Number of training steps between every
validation loss check.<br/> `batch_size`: int=32, number of different
series in each batch.<br/> `step_size`: int=1, step size between each
window of temporal data.<br/> `scaler_type`: str=‘identity’, type of
scaler for temporal inputs normalization see [temporal
scalers](https://nixtla.github.io/neuralforecast/common.scalers.html).<br/>
`random_seed`: int=1, random_seed for pytorch initializer and numpy
generators.<br/> `num_workers_loader`: int=os.cpu_count(), workers to be
used by `TimeSeriesDataLoader`.<br/> `drop_last_loader`: bool=False, if
True `TimeSeriesDataLoader` drops last non-full batch.<br/> `alias`: str,
optional, Custom name of the model.<br/> `optimizer`: Subclass of
‘torch.optim.Optimizer’, optional, user specified optimizer instead of
the default choice (Adam).<br/> `optimizer_kwargs`: dict, optional, list
of parameters used by the user specified `optimizer`.<br/>
`lr_scheduler`: Subclass of ‘torch.optim.lr_scheduler.LRScheduler’,
optional, user specified lr_scheduler instead of the default choice
(StepLR).<br/> `lr_scheduler_kwargs`: dict, optional, list of parameters
used by the user specified `lr_scheduler`.<br/> `**trainer_kwargs`: int,
keyword trainer arguments inherited from [PyTorch Lighning’s
trainer](https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.trainer.trainer.trainer.html?highlight=trainer).<br/>

**References:**<br/> - [Das, Abhimanyu, Weihao Kong, Andrew Leach, Shaan
Mathur, Rajat Sen, and Rose Yu (2024). “Long-term Forecasting with TiDE:
Time-series Dense Encoder.”](http://arxiv.org/abs/2304.08424)\*

------------------------------------------------------------------------

### TiDE.fit

> ``` text
>  TiDE.fit (dataset, val_size=0, test_size=0, random_seed=None,
>            distributed_config=None)
> ```

\*Fit.

The `fit` method, optimizes the neural network’s weights using the
initialization parameters (`learning_rate`, `windows_batch_size`, …) and
the `loss` function as defined during the initialization. Within `fit`
we use a PyTorch Lightning `Trainer` that inherits the initialization’s
`self.trainer_kwargs`, to customize its inputs, see [PL’s trainer
arguments](https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.trainer.trainer.trainer.html?highlight=trainer).

The method is designed to be compatible with SKLearn-like classes and in
particular to be compatible with the StatsForecast library.

By default the `model` is not saving training checkpoints to protect
disk memory, to get them change `enable_checkpointing=True` in
`__init__`.

**Parameters:**<br/> `dataset`: NeuralForecast’s
[`TimeSeriesDataset`](https://Nixtla.github.io/neuralforecast/tsdataset.html#timeseriesdataset),
see
[documentation](https://nixtla.github.io/neuralforecast/tsdataset.html).<br/>
`val_size`: int, validation size for temporal cross-validation.<br/>
`random_seed`: int=None, random_seed for pytorch initializer and numpy
generators, overwrites model.\_\_init\_\_’s.<br/> `test_size`: int, test
size for temporal cross-validation.<br/>\*

------------------------------------------------------------------------

### TiDE.predict

> ``` text
>  TiDE.predict (dataset, test_size=None, step_size=1, random_seed=None,
>                **data_module_kwargs)
> ```

\*Predict.

Neural network prediction with PL’s `Trainer` execution of
`predict_step`.

**Parameters:**<br/> `dataset`: NeuralForecast’s
[`TimeSeriesDataset`](https://Nixtla.github.io/neuralforecast/tsdataset.html#timeseriesdataset),
see
[documentation](https://nixtla.github.io/neuralforecast/tsdataset.html).<br/>
`test_size`: int=None, test size for temporal cross-validation.<br/>
`step_size`: int=1, Step size between each window.<br/> `random_seed`:
int=None, random_seed for pytorch initializer and numpy generators,
overwrites model.\_\_init\_\_’s.<br/> `**data_module_kwargs`: PL’s
TimeSeriesDataModule args, see
[documentation](https://pytorch-lightning.readthedocs.io/en/1.6.1/extensions/datamodules.html#using-a-datamodule).\*

## 3. Usage Examples

Train model and forecast future values with `predict` method.

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from neuralforecast.utils import AirPassengersDF as Y_df
from neuralforecast.tsdataset import TimeSeriesDataset
```


```python
Y_train_df = Y_df[Y_df.ds<='1959-12-31'] # 132 train
Y_test_df = Y_df[Y_df.ds>'1959-12-31']   # 12 test

dataset, *_ = TimeSeriesDataset.from_df(Y_train_df)
model = TiDE(h=12, input_size=24, max_steps=500, scaler_type='standard')
model.fit(dataset=dataset)
y_hat = model.predict(dataset=dataset)
Y_test_df['TiDE'] = y_hat

#test we recover the same forecast
y_hat2 = model.predict(dataset=dataset)
test_eq(y_hat, y_hat2)

pd.concat([Y_train_df, Y_test_df]).drop('unique_id', axis=1).set_index('ds').plot()
```

Creating probabilistic forecasts

```python
import numpy as np
import pandas as pd
import pytorch_lightning as pl
import matplotlib.pyplot as plt

from neuralforecast import NeuralForecast
from neuralforecast.losses.pytorch import GMM, DistributionLoss
from neuralforecast.utils import AirPassengersPanel, AirPassengersStatic
```


```python
# Plot predictions
Y_train_df = AirPassengersPanel[AirPassengersPanel.ds<AirPassengersPanel['ds'].values[-12]] # 132 train
Y_test_df = AirPassengersPanel[AirPassengersPanel.ds>=AirPassengersPanel['ds'].values[-12]].reset_index(drop=True) # 12 test

fcst = NeuralForecast(
    models=[
            TiDE(h=12,
                input_size=24,
                loss=GMM(n_components=7, return_params=True, level=[80,90]),
                max_steps=500,
                scaler_type='standard',
                futr_exog_list=['y_[lag12]'],
                hist_exog_list=None,
                stat_exog_list=['airline1'],
                ),     
    ],
    freq='M'
)
fcst.fit(df=Y_train_df, static_df=AirPassengersStatic)
forecasts = fcst.predict(futr_df=Y_test_df)

# Plot quantile predictions
Y_hat_df = forecasts.reset_index(drop=False).drop(columns=['unique_id','ds'])
plot_df = pd.concat([Y_test_df, Y_hat_df], axis=1)
plot_df = pd.concat([Y_train_df, plot_df])

plot_df = plot_df[plot_df.unique_id=='Airline1'].drop('unique_id', axis=1)
plt.plot(plot_df['ds'], plot_df['y'], c='black', label='True')
plt.plot(plot_df['ds'], plot_df['TiDE-median'], c='blue', label='median')
plt.fill_between(x=plot_df['ds'][-12:], 
                 y1=plot_df['TiDE-lo-90'][-12:].values,
                 y2=plot_df['TiDE-hi-90'][-12:].values,
                 alpha=0.4, label='level 90')
plt.legend()
plt.grid()
```

