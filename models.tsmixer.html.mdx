---
description: >-
  Time-Series Mixer (`TSMixer`) is a MLP-based multivariate time-series
  forecasting model. `TSMixer` jointly learns temporal and cross-sectional
  representations of the time-series by repeatedly combining time- and feature
  information using stacked mixing layers. A mixing layer consists of a
  sequential time- and feature Multi Layer Perceptron (`MLP`). Note: this model
  cannot handle exogenous inputs. If you want to use additional exogenous
  inputs, use `TSMixerx`.
output-file: models.tsmixer.html
title: TSMixer
---


<figure>
<img src="imgs_models/tsmixer.png"
alt="Figure 1. TSMixer for multivariate time series forecasting." />
<figcaption aria-hidden="true">Figure 1. TSMixer for multivariate time
series forecasting.</figcaption>
</figure>

## 1. Auxiliary Functions

## 1.1 Mixing layers

A mixing layer consists of a sequential time- and feature Multi Layer
Perceptron
([`MLP`](https://nixtlaverse.nixtla.io/neuralforecast/models.mlp.html#mlp)).

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/tsmixerx.py#L68"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### MixingLayer

> ``` text
>  MixingLayer (n_series, input_size, dropout, ff_dim)
> ```

*MixingLayer*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/tsmixerx.py#L37"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### FeatureMixing

> ``` text
>  FeatureMixing (n_series, input_size, dropout, ff_dim)
> ```

*FeatureMixing*

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/tsmixerx.py#L17"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TemporalMixing

> ``` text
>  TemporalMixing (n_series, input_size, dropout)
> ```

*TemporalMixing*

## 2. Model

------------------------------------------------------------------------

<a
href="https://github.com/Nixtla/neuralforecast/blob/main/neuralforecast/models/tsmixer.py#L97"
target="_blank" style={{ float: "right", fontSize: "smaller" }}>source</a>

### TSMixer

> ``` text
>  TSMixer (h, input_size, n_series, futr_exog_list=None,
>           hist_exog_list=None, stat_exog_list=None,
>           exclude_insample_y=False, n_block=2, ff_dim=64, dropout=0.9,
>           revin=True, loss=MAE(), valid_loss=None, max_steps:int=1000,
>           learning_rate:float=0.001, num_lr_decays:int=-1,
>           early_stop_patience_steps:int=-1, val_check_steps:int=100,
>           batch_size:int=32, valid_batch_size:Optional[int]=None,
>           windows_batch_size=32, inference_windows_batch_size=32,
>           start_padding_enabled=False, step_size:int=1,
>           scaler_type:str='identity', random_seed:int=1,
>           drop_last_loader:bool=False, alias:Optional[str]=None,
>           optimizer=None, optimizer_kwargs=None, lr_scheduler=None,
>           lr_scheduler_kwargs=None, dataloader_kwargs=None,
>           **trainer_kwargs)
> ```

\*TSMixer

Time-Series Mixer
([`TSMixer`](https://nixtlaverse.nixtla.io/neuralforecast/models.tsmixer.html#tsmixer))
is a MLP-based multivariate time-series forecasting model.
[`TSMixer`](https://nixtlaverse.nixtla.io/neuralforecast/models.tsmixer.html#tsmixer)
jointly learns temporal and cross-sectional representations of the
time-series by repeatedly combining time- and feature information using
stacked mixing layers. A mixing layer consists of a sequential time- and
feature Multi Layer Perceptron
([`MLP`](https://nixtlaverse.nixtla.io/neuralforecast/models.mlp.html#mlp)).

**Parameters:**<br/> `h`: int, forecast horizon.<br/> `input_size`: int,
considered autorregresive inputs (lags), y=\[1,2,3,4\] input_size=2 -\>
lags=\[1,2\].<br/> `n_series`: int, number of time-series.<br/>
`futr_exog_list`: str list, future exogenous columns.<br/>
`hist_exog_list`: str list, historic exogenous columns.<br/>
`stat_exog_list`: str list, static exogenous columns.<br/>
`exclude_insample_y`: bool=False, if True excludes the target variable
from the input features.<br/> `n_block`: int=2, number of mixing layers
in the model.<br/> `ff_dim`: int=64, number of units for the second
feed-forward layer in the feature MLP.<br/> `dropout`: float=0.9, dropout
rate between (0, 1) .<br/> `revin`: bool=True, if True uses Reverse
Instance Normalization to process inputs and outputs.<br/> `loss`:
PyTorch module, instantiated train loss class from [losses
collection](https://nixtla.github.io/neuralforecast/losses.pytorch.html).<br/>
`valid_loss`: PyTorch module=`loss`, instantiated valid loss class from
[losses
collection](https://nixtla.github.io/neuralforecast/losses.pytorch.html).<br/>
`max_steps`: int=1000, maximum number of training steps.<br/>
`learning_rate`: float=1e-3, Learning rate between (0, 1).<br/>
`num_lr_decays`: int=-1, Number of learning rate decays, evenly
distributed across max_steps.<br/> `early_stop_patience_steps`: int=-1,
Number of validation iterations before early stopping.<br/>
`val_check_steps`: int=100, Number of training steps between every
validation loss check.<br/> `batch_size`: int=32, number of different
series in each batch.<br/> `valid_batch_size`: int=None, number of
different series in each validation and test batch, if None uses
batch_size.<br/> `windows_batch_size`: int=32, number of windows to
sample in each training batch, default uses all.<br/>
`inference_windows_batch_size`: int=32, number of windows to sample in
each inference batch, -1 uses all.<br/> `start_padding_enabled`:
bool=False, if True, the model will pad the time series with zeros at
the beginning, by input size.<br/> `step_size`: int=1, step size between
each window of temporal data.<br/> `scaler_type`: str=‘identity’, type of
scaler for temporal inputs normalization see [temporal
scalers](https://nixtla.github.io/neuralforecast/common.scalers.html).<br/>
`random_seed`: int=1, random_seed for pytorch initializer and numpy
generators.<br/> `drop_last_loader`: bool=False, if True
`TimeSeriesDataLoader` drops last non-full batch.<br/> `alias`: str,
optional, Custom name of the model.<br/> `optimizer`: Subclass of
‘torch.optim.Optimizer’, optional, user specified optimizer instead of
the default choice (Adam).<br/> `optimizer_kwargs`: dict, optional, list
of parameters used by the user specified `optimizer`.<br/>
`lr_scheduler`: Subclass of ‘torch.optim.lr_scheduler.LRScheduler’,
optional, user specified lr_scheduler instead of the default choice
(StepLR).<br/> `lr_scheduler_kwargs`: dict, optional, list of parameters
used by the user specified `lr_scheduler`.<br/>  
`dataloader_kwargs`: dict, optional, list of parameters passed into the
PyTorch Lightning dataloader by the `TimeSeriesDataLoader`. <br/>
`**trainer_kwargs`: int, keyword trainer arguments inherited from
[PyTorch Lighning’s
trainer](https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.trainer.trainer.Trainer.html?highlight=trainer).<br/>

**References:**<br/> - [Chen, Si-An, Chun-Liang Li, Nate Yoder, Sercan O.
Arik, and Tomas Pfister (2023). “TSMixer: An All-MLP Architecture for
Time Series Forecasting.”](http://arxiv.org/abs/2303.06053)\*

------------------------------------------------------------------------

### TSMixer.fit

> ``` text
>  TSMixer.fit (dataset, val_size=0, test_size=0, random_seed=None,
>               distributed_config=None)
> ```

\*Fit.

The `fit` method, optimizes the neural network’s weights using the
initialization parameters (`learning_rate`, `windows_batch_size`, …) and
the `loss` function as defined during the initialization. Within `fit`
we use a PyTorch Lightning `Trainer` that inherits the initialization’s
`self.trainer_kwargs`, to customize its inputs, see [PL’s trainer
arguments](https://pytorch-lightning.readthedocs.io/en/stable/api/pytorch_lightning.trainer.trainer.Trainer.html?highlight=trainer).

The method is designed to be compatible with SKLearn-like classes and in
particular to be compatible with the StatsForecast library.

By default the `model` is not saving training checkpoints to protect
disk memory, to get them change `enable_checkpointing=True` in
`__init__`.

**Parameters:**<br/> `dataset`: NeuralForecast’s
[`TimeSeriesDataset`](https://nixtlaverse.nixtla.io/neuralforecast/tsdataset.html#timeseriesdataset),
see
[documentation](https://nixtla.github.io/neuralforecast/tsdataset.html).<br/>
`val_size`: int, validation size for temporal cross-validation.<br/>
`random_seed`: int=None, random_seed for pytorch initializer and numpy
generators, overwrites model.\_\_init\_\_’s.<br/> `test_size`: int, test
size for temporal cross-validation.<br/>\*

------------------------------------------------------------------------

### TSMixer.predict

> ``` text
>  TSMixer.predict (dataset, test_size=None, step_size=1, random_seed=None,
>                   quantiles=None, **data_module_kwargs)
> ```

\*Predict.

Neural network prediction with PL’s `Trainer` execution of
`predict_step`.

**Parameters:**<br/> `dataset`: NeuralForecast’s
[`TimeSeriesDataset`](https://nixtlaverse.nixtla.io/neuralforecast/tsdataset.html#timeseriesdataset),
see
[documentation](https://nixtla.github.io/neuralforecast/tsdataset.html).<br/>
`test_size`: int=None, test size for temporal cross-validation.<br/>
`step_size`: int=1, Step size between each window.<br/> `random_seed`:
int=None, random_seed for pytorch initializer and numpy generators,
overwrites model.\_\_init\_\_’s.<br/> `quantiles`: list of floats,
optional (default=None), target quantiles to predict. <br/>
`**data_module_kwargs`: PL’s TimeSeriesDataModule args, see
[documentation](https://pytorch-lightning.readthedocs.io/en/1.6.1/extensions/datamodules.html#using-a-datamodule).\*


```python
# Unit tests for models
logging.getLogger("pytorch_lightning").setLevel(logging.ERROR)
logging.getLogger("lightning_fabric").setLevel(logging.ERROR)
with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    check_model(TSMixer, ["airpassengers"])
```

## 3. Usage Examples

Train model and forecast future values with `predict` method.


```python
import pandas as pd
import matplotlib.pyplot as plt

from neuralforecast import NeuralForecast
from neuralforecast.models import TSMixer
from neuralforecast.utils import AirPassengersPanel, AirPassengersStatic
from neuralforecast.losses.pytorch import MAE, MQLoss

Y_train_df = AirPassengersPanel[AirPassengersPanel.ds<AirPassengersPanel['ds'].values[-12]].reset_index(drop=True) # 132 train
Y_test_df = AirPassengersPanel[AirPassengersPanel.ds>=AirPassengersPanel['ds'].values[-12]].reset_index(drop=True) # 12 test

model = TSMixer(h=12,
                input_size=24,
                n_series=2, 
                n_block=4,
                ff_dim=4,
                dropout=0,
                revin=True,
                scaler_type='standard',
                max_steps=500,
                early_stop_patience_steps=-1,
                val_check_steps=5,
                learning_rate=1e-3,
                loss=MQLoss(),
                batch_size=32
                )

fcst = NeuralForecast(models=[model], freq='ME')
fcst.fit(df=Y_train_df, static_df=AirPassengersStatic, val_size=12)
forecasts = fcst.predict(futr_df=Y_test_df)

# Plot predictions
fig, ax = plt.subplots(1, 1, figsize = (20, 7))
Y_hat_df = forecasts.reset_index(drop=False).drop(columns=['unique_id','ds'])
plot_df = pd.concat([Y_test_df, Y_hat_df], axis=1)
plot_df = pd.concat([Y_train_df, plot_df])

plot_df = plot_df[plot_df.unique_id=='Airline2'].drop('unique_id', axis=1)
plt.plot(plot_df['ds'], plot_df['y'], c='black', label='True')
plt.plot(plot_df['ds'], plot_df['TSMixer-median'], c='blue', label='median')
plt.fill_between(x=plot_df['ds'][-12:], 
                 y1=plot_df['TSMixer-lo-90'][-12:].values,
                 y2=plot_df['TSMixer-hi-90'][-12:].values,
                 alpha=0.4, label='level 90')
ax.set_title('AirPassengers Forecast', fontsize=22)
ax.set_ylabel('Monthly Passengers', fontsize=20)
ax.set_xlabel('Year', fontsize=20)
ax.legend(prop={'size': 15})
ax.grid()
```

Using `cross_validation` to forecast multiple historic values.


```python
fcst = NeuralForecast(models=[model], freq='M')
forecasts = fcst.cross_validation(df=AirPassengersPanel, static_df=AirPassengersStatic, n_windows=2, step_size=12)

# Plot predictions
fig, ax = plt.subplots(1, 1, figsize = (20, 7))
Y_hat_df = forecasts.loc['Airline1']
Y_df = AirPassengersPanel[AirPassengersPanel['unique_id']=='Airline1']

plt.plot(Y_df['ds'], Y_df['y'], c='black', label='True')
plt.plot(Y_hat_df['ds'], Y_hat_df['TSMixer-median'], c='blue', label='Forecast')
ax.set_title('AirPassengers Forecast', fontsize=22)
ax.set_ylabel('Monthly Passengers', fontsize=20)
ax.set_xlabel('Year', fontsize=20)
ax.legend(prop={'size': 15})
ax.grid()
```

